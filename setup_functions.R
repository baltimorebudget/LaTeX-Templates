#' Retrieve RMD file paths
#'
#' Retrieves the paths for RMD files for the book specified in params$book
#'
#' @param rmd_path Path to analyst-edited RMD files
#' @return A vector of paths.
#'
#' @export

retrieve_rmd_paths <- function(rmd_path) {

  list.files(rmd_path, ".Rmd", full.names = TRUE, recursive = TRUE) %>%
    setdiff(list.files(
      rmd_path,
      switch(params$book, # pattern of file names to remove
             "prelim" = "E_|S_|03_fiscal_env",
             "exec" = "P_|[a-z]S_",
             "sota" = "P_|E_"),
      full.names = TRUE, recursive = TRUE))
}

#' Compile Preliminary, Executive Summary, or Summary of the Adopted budget book
#'
#' @param preview a vector of .Rmd files to generate; if none provided, then
#'  will generate entire book
#' @param get_rmd logical, should the function delete the rmd files from the
#' project folder to grab the latest analyst-edited files? useful to set to
#' FALSE for when the G drive is down
#' @param rmd_path Path to analyst-edited RMD files
#' @param data_dates A list of the dates data were edited; generated by the
#' data_prep project
#' @param format "pdf" or "html" or a vector of the two; by default, it will run both
#'
#' @return A data frame.
#'
#' @import dplyr
#' @export

compile_prelim_exec_sota <- function(preview = NULL, rmd_path, data_dates, format = c("pdf", "html")) {

  if (!format %in% c("pdf", "html")) {
    stop("format must be 'pdf' and/or 'html'")
  }

  timing <- list(start = Sys.time())

  time_compiled <- now()

  if (file.exists("_main.Rmd")) {
    file.remove("_main.Rmd")
  }

  if (!is.null(preview)) {

    # get the preview file
    # very senstive to working directory
    rmd_files <- list.files(path = rmd_path, pattern = paste0(preview, collapse = "|"), recursive = TRUE, full.names = TRUE)

    if(length(rmd_files) == 0) {
      stop("No matching rmd files found to generate preview. Check file names and include '.Rmd' in the file name.")
    }

  } else {

    rmd_files <- list.files(
      rmd_path, ".*\\.Rmd$", full.names = TRUE, recursive = TRUE)

    rmd_files_ignore <- list.files(
      rmd_path,
      paste(switch(params$book, # pattern of file names to remove
                   "prelim" = "E_.*\\.Rmd$|S_.*\\.Rmd$|03_fiscal_env.*\\.Rmd$",
                   "exec" = "P_.*\\.Rmd$|[a-z]S_.*\\.Rmd$",
                   "sota" = "P_.*\\.Rmd$|E_.*\\.Rmd$")),
      full.names = TRUE, recursive = TRUE)

    rmd_files <- setdiff(rmd_files, rmd_files_ignore)

    rmd_files <- gsub(paste0(rmd_path, "/"), "", rmd_files)
  }

  write_header(time_compiled, rmd_path)

  write_before_body(rmd_files, rmd_path, time_compiled, data_dates)

  file_name <- ifelse(
    !is.null(preview), paste0("chapter_preview_", format(Sys.time(), format = "%Y-%m-%d_%H-%M")),
    paste0("fy", params$fy, "_", params$book, "_", format(Sys.time(), format = "%Y-%m-%d_%H-%M")))

  if ("pdf" %in% format) {

    bookdown <-
      paste0("output_dir: '../",
             switch(params$book, prelim = "1_prelim", exec = "2_exec", sota = "5_sota"),
             "'\nlang: 'english'",
             "\nrmd_files: \n  - ", paste(rmd_files, collapse = "\n  - "),
             "\ndelete_merged_file: TRUE", collapse = "")

    writeLines(bookdown,  paste0(rmd_path, "_bookdown.yml"))

    xfun::in_dir(
      rmd_path,
      render_book(rmd_files, output_file = paste0(file_name, ".pdf"),
                  output_format = "bookdown::pdf_book",
                  config_file = "_bookdown.yml", clean = FALSE))
  }
  if ("html" %in% format) {
    render_book(rmd_files, output_file = file_name, output_format = "bookdown::gitbook", config_file = "_bookdown.yml")
  }

  timing$end <- Sys.time()

  print(difftime(timing$end, timing$start))
}

#' Mark draft
#'
#' Makes specified content red in order to highlight content that
#'  needs to be revisited before publication.
#'
#' @param x A string, text to turn red
#' @return A formatted string.
#'
#' @export

mark_draft <- function(x){
  kableExtra::text_spec(x, color = "red")
}
